<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Neon Frontier: Bugfix Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --neon: #00f2ff; --neon-pink: #ff0055; --bg: #050505; }
        body { margin: 0; background: var(--bg); color: var(--neon); font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        #menu { 
            background: rgba(10, 10, 10, 0.95); padding: 40px; border: 2px solid var(--neon); 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            z-index: 100; border-radius: 20px; text-align: center; box-shadow: 0 0 50px rgba(0, 242, 255, 0.3);
        }

        input { padding: 12px; border: 1px solid var(--neon); background: #111; color: var(--neon); margin: 10px 0; width: 250px; border-radius: 5px; outline: none; }
        button { padding: 12px 25px; background: var(--neon); color: #000; border: none; font-weight: bold; cursor: pointer; margin: 5px; border-radius: 5px; transition: 0.3s; }
        button:hover { background: #fff; box-shadow: 0 0 20px #fff; }
        .selected { border: 2px solid white !important; box-shadow: 0 0 15px var(--neon); }

        .ui-panel { position: absolute; padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid var(--neon); border-radius: 10px; pointer-events: none; z-index: 10; }
        #player-info { top: 20px; left: 20px; width: 200px; }
        #wave-info { top: 20px; right: 20px; text-align: right; display: none; }
        
        .hp-container { width: 100%; height: 12px; background: #222; border-radius: 6px; overflow: hidden; margin-top: 5px; border: 1px solid #444; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0055, #00f2ff); transition: width 0.1s linear; }

        #inventory { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .slot { width: 70px; height: 70px; border: 2px solid #333; background: rgba(20,20,20,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 10px; border-radius: 10px; }
        .slot.active { border-color: var(--neon); box-shadow: 0 0 15px var(--neon); color: #fff; transform: translateY(-5px); }
        
        #chat-container { position: absolute; bottom: 100px; left: 20px; width: 250px; }
        #chat-window { height: 100px; overflow-y: auto; font-size: 12px; margin-bottom: 5px; color: #ccc; pointer-events: none; }
    </style>
</head>
<body>

    <div id="menu">
        <h1 style="letter-spacing: 8px;">NEON FRONTIER</h1>
        <p>DEINE ID: <span id="my-id" style="color:var(--neon-pink); font-size: 22px;">....</span></p>
        <input type="text" id="username" placeholder="Dein Name" value="Ace" maxlength="10">
        <div style="margin: 10px;">
            <button id="btn-1v1" onclick="setMode('1v1')" class="selected">1 VS 1</button>
            <button id="btn-coop" onclick="setMode('coop')">COOP SURVIVAL</button>
        </div>
        <input type="text" id="remote-id" placeholder="Partner ID eingeben"><br>
        <button id="connect-btn" style="width: 100%; background: var(--neon-pink); color: white;">START MISSION</button>
    </div>

    <div id="player-info" class="ui-panel">
        <b id="ui-display-name">Spieler</b>
        <div class="hp-container"><div id="hp-bar"></div></div>
        <small>WAFFE: <span id="ui-weapon-name">Pistole</span></small>
    </div>

    <div id="wave-info" class="ui-panel">
        <span style="color: var(--neon-pink)">WELLE <span id="ui-wave">1</span></span><br>
        DROIDEN: <span id="ui-enemies">0</span>
    </div>

    <div id="chat-container">
        <div id="chat-window"></div>
        <input type="text" id="chat-input" placeholder="ENTER für Chat...">
    </div>

    <div id="inventory">
        <div class="slot active" id="slot1"><b>1</b><span>Pistole</span></div>
        <div class="slot" id="slot2"><b>2</b><span>Shotgun</span></div>
        <div class="slot" id="slot3"><b>3</b><span>Messer</span></div>
        <div class="slot" id="slot4"><b>4</b><span>Wall</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const WEAPONS = {
            1: { name: 'Pistole', dmg: 10, rate: 200, color: '#00f2ff' },
            2: { name: 'Shotgun', dmg: 8, rate: 800, color: '#ffaa00' },
            3: { name: 'Messer', dmg: 40, rate: 300, range: 60, color: '#ff0055' },
            4: { name: 'Wall', hp: 300 }
        };

        let myId = Math.floor(1000 + Math.random() * 9000).toString();
        const peer = new Peer('NF-' + myId);
        let conn;

        let gameMode = '1v1';
        let me = { id: myId, name: 'Pilot', x: 200, y: 200, hp: 100, angle: 0, weapon: 1, hitTimer: 0 };
        let rival = { id: '', name: 'Gegner', x: -5000, y: -5000, hp: 100, angle: 0, weapon: 1, active: false, hitTimer: 0 };
        
        let walls = [], bullets = [], enemies = [], particles = [];
        let wave = 0, isHost = false, lastShotTime = 0;
        const keys = {};

        function setMode(m) {
            gameMode = m;
            document.getElementById('btn-1v1').className = m === '1v1' ? 'selected' : '';
            document.getElementById('btn-coop').className = m === 'coop' ? 'selected' : '';
        }

        peer.on('open', id => document.getElementById('my-id').innerText = id);
        peer.on('connection', c => { conn = c; isHost = true; setupConn(); });

        document.getElementById('connect-btn').onclick = () => {
            const rId = document.getElementById('remote-id').value;
            if(!rId) return;
            me.name = document.getElementById('username').value || "Pilot";
            conn = peer.connect(rId);
            isHost = false;
            setupConn();
        };

        function setupConn() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('ui-display-name').innerText = me.name;
            if(gameMode === 'coop') document.getElementById('wave-info').style.display = 'block';

            conn.on('open', () => {
                rival.active = true;
                conn.send({ type: 'init', name: me.name, mode: gameMode });
                requestAnimationFrame(gameLoop);
            });

            conn.on('data', data => {
                if(data.type === 'init') { rival.name = data.name; gameMode = data.mode; if(gameMode === 'coop') document.getElementById('wave-info').style.display = 'block'; }
                if(data.type === 'sync') { 
                    rival.x = data.x; rival.y = data.y; rival.angle = data.angle; 
                    rival.hp = data.hp; rival.weapon = data.weapon; 
                }
                if(data.type === 'shot') bullets.push(data.b);
                if(data.type === 'build') walls.push(data.wall);
                if(data.type === 'hit') { 
                    me.hp -= data.dmg; 
                    me.hitTimer = 10; // Flash Effekt
                    createExplosion(me.x, me.y, '#ff0055');
                }
                if(data.type === 'msg') addChat(data.sender, data.txt);
                if(data.type === 'sync_enemies') enemies = data.enemies;
                if(data.type === 'sync_wave') wave = data.wave;
                if(data.type === 'wall_break') walls = walls.filter(w => !(w.x === data.x && w.y === data.y));
            });
        }

        function addChat(sender, txt) {
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:var(--neon-pink)">${sender}:</span> ${txt}`;
            const win = document.getElementById('chat-window');
            win.appendChild(div); win.scrollTop = win.scrollHeight;
        }

        function createExplosion(x, y, col) {
            for(let i=0; i<10; i++) {
                particles.push({ x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 1.0, col });
            }
        }

        window.onkeydown = e => {
            if(document.activeElement.id === 'chat-input') {
                if(e.key === 'Enter') {
                    const txt = document.getElementById('chat-input').value;
                    if(txt && conn) { addChat(me.name, txt); conn.send({ type: 'msg', sender: me.name, txt }); }
                    document.getElementById('chat-input').value = '';
                    document.getElementById('chat-input').blur();
                }
                return;
            }
            keys[e.key.toLowerCase()] = true;
            if(['1','2','3','4'].includes(e.key)) { me.weapon = parseInt(e.key); updateUI(); }
            if(e.key === 'Enter') document.getElementById('chat-input').focus();
        };
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;
        window.onmousemove = e => me.angle = Math.atan2(e.clientY - me.y, e.clientX - me.x);

        window.onmousedown = () => {
            if(document.activeElement.id === 'chat-input') return;
            const now = Date.now();
            const w = WEAPONS[me.weapon];
            if(now - lastShotTime < w.rate) return;

            if(me.weapon === 4) {
                const wx = Math.floor((me.x + Math.cos(me.angle)*60)/40)*40;
                const wy = Math.floor((me.y + Math.sin(me.angle)*60)/40)*40;
                if(!walls.some(wl => wl.x === wx && wl.y === wy)) {
                    const wall = { x: wx, y: wy, hp: w.hp };
                    walls.push(wall); if(conn) conn.send({ type: 'build', wall });
                }
            } else if(me.weapon === 3) {
                // Messer Treffer Check
                if(gameMode === '1v1' && Math.hypot(me.x - rival.x, me.y - rival.y) < w.range) {
                    conn.send({ type: 'hit', dmg: w.dmg });
                    rival.hitTimer = 10;
                }
                enemies.forEach((en, i) => {
                    if(Math.hypot(me.x - en.x, me.y - en.y) < w.range) { en.hp -= w.dmg; createExplosion(en.x, en.y, '#ff0000'); }
                });
            } else {
                const shoot = (ang) => {
                    const b = { x: me.x, y: me.y, vx: Math.cos(ang)*15, vy: Math.sin(ang)*15, owner: me.id, dmg: w.dmg, col: w.color };
                    bullets.push(b); if(conn) conn.send({ type: 'shot', b });
                };
                shoot(me.angle);
                if(me.weapon === 2) { shoot(me.angle-0.15); shoot(me.angle+0.15); }
            }
            lastShotTime = now;
        };

        function updateUI() {
            document.getElementById('hp-bar').style.width = Math.max(0, me.hp) + '%';
            document.getElementById('ui-weapon-name').innerText = WEAPONS[me.weapon].name;
            document.getElementById('ui-wave').innerText = wave;
            document.getElementById('ui-enemies').innerText = enemies.length;
            for(let i=1; i<=4; i++) document.getElementById('slot'+i).className = me.weapon === i ? 'slot active' : 'slot';
        }

        function gameLoop() {
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = '#111'; ctx.beginPath();
            for(let x=0; x<canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Collision & Move
            let nx = me.x, ny = me.y;
            if(keys['w']) ny -= 4.5; if(keys['s']) ny += 4.5;
            if(keys['a']) nx -= 4.5; if(keys['d']) nx += 4.5;
            const isWall = (tx, ty) => walls.some(w => tx+15 > w.x && tx-15 < w.x+40 && ty+15 > w.y && ty-15 < w.y+40);
            if(!isWall(nx, me.y)) me.x = nx;
            if(!isWall(me.x, ny)) me.y = ny;

            if(conn) conn.send({ type: 'sync', x: me.x, y: me.y, angle: me.angle, hp: me.hp, weapon: me.weapon });

            // Particles
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 2, 2);
                if(p.life <= 0) particles.splice(i, 1);
            });
            ctx.globalAlpha = 1.0;

            // Bullets & Hit Detection
            bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy;
                ctx.fillStyle = b.col; ctx.shadowBlur = 10; ctx.shadowColor = b.col;
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, 7); ctx.fill();
                
                // Wall Hit
                walls.forEach((w, wi) => {
                    if(b.x > w.x && b.x < w.x+40 && b.y > w.y && b.y < w.y+40) {
                        w.hp -= b.dmg; bullets.splice(i, 1);
                        if(w.hp <= 0) { if(conn) conn.send({type:'wall_break', x:w.x, y:w.y}); walls.splice(wi, 1); }
                    }
                });

                // 1v1 Hit Detection (Berechnet beim Schützen!)
                if(gameMode === '1v1' && b.owner === me.id && Math.hypot(rival.x - b.x, rival.y - b.y) < 22) {
                    conn.send({ type: 'hit', dmg: b.dmg }); // Sende Treffer an Gegner
                    rival.hitTimer = 10; // Visual für mich
                    bullets.splice(i, 1);
                }

                // Enemy Hit (Host)
                if(isHost && gameMode === 'coop') {
                    enemies.forEach((en, ei) => {
                        if(Math.hypot(en.x - b.x, en.y - b.y) < 22) {
                            en.hp -= b.dmg; bullets.splice(i, 1);
                            if(en.hp <= 0) { createExplosion(en.x, en.y, '#f00'); enemies.splice(ei, 1); }
                        }
                    });
                }
                
                if(b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) bullets.splice(i, 1);
            });

            // AI (Host)
            if(isHost && gameMode === 'coop') {
                if(enemies.length === 0) {
                    wave++;
                    for(let i=0; i<3+wave*2; i++) {
                        enemies.push({ x: Math.random()*canvas.width, y: -50, hp: 40+wave*10, speed: 1.5+Math.random(), offset: Math.random()*100 });
                    }
                    conn.send({ type: 'sync_wave', wave });
                }
                enemies.forEach(en => {
                    const target = Math.hypot(me.x-en.x, me.y-en.y) < Math.hypot(rival.x-en.x, rival.y-en.y) ? me : rival;
                    const angle = Math.atan2(target.y-en.y, target.x-en.x);
                    const orbit = Math.sin(Date.now()*0.003 + en.offset) * 0.4;
                    en.x += Math.cos(angle + orbit) * en.speed;
                    en.y += Math.sin(angle + orbit) * en.speed;
                    if(Math.hypot(me.x-en.x, me.y-en.y) < 25) { me.hp -= 0.4; me.hitTimer = 5; }
                });
                conn.send({ type: 'sync_enemies', enemies });
            }

            // Draw
            walls.forEach(w => {
                ctx.strokeStyle = varColor('--neon'); ctx.strokeRect(w.x, w.y, 40, 40);
                ctx.fillStyle = `rgba(0, 242, 255, ${w.hp/300*0.4})`; ctx.fillRect(w.x+2, w.y+2, 36, 36);
            });

            enemies.forEach(en => {
                ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 15; ctx.shadowColor = 'red';
                ctx.beginPath(); ctx.arc(en.x, en.y, 13, 0, 7); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(en.x-4, en.y-4, 8, 2);
            });

            drawPlayer(me, '#00f2ff');
            if(rival.active) drawPlayer(rival, '#ff0055');

            if(me.hp <= 0) { alert("MISSION FEHLGESCHLAGEN!"); location.reload(); }
            
            if(me.hitTimer > 0) me.hitTimer--;
            if(rival.hitTimer > 0) rival.hitTimer--;
            
            ctx.shadowBlur = 0;
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function drawPlayer(p, col) {
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            // Flash white when hit
            const drawCol = p.hitTimer > 0 ? '#fff' : col;
            ctx.shadowBlur = 20; ctx.shadowColor = drawCol;
            ctx.fillStyle = drawCol;
            ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-12, -14); ctx.lineTo(-12, 14); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.fillRect(10, -2, 12, 4);
            ctx.restore();
            ctx.fillStyle = '#fff'; ctx.font = "bold 13px Arial"; ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y - 35);
        }

        function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Neon Frontier: Pro Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --neon: #00f2ff; --neon-pink: #ff0055; --bg: #050505; }
        body { margin: 0; background: var(--bg); color: var(--neon); font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        #menu { 
            background: rgba(10, 10, 10, 0.95); padding: 40px; border: 2px solid var(--neon); 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            z-index: 100; border-radius: 20px; text-align: center; box-shadow: 0 0 50px rgba(0, 242, 255, 0.3);
        }

        input { padding: 12px; border: 1px solid var(--neon); background: #111; color: var(--neon); margin: 10px 0; width: 250px; border-radius: 5px; }
        button { padding: 12px 25px; background: var(--neon); color: #000; border: none; font-weight: bold; cursor: pointer; margin: 5px; border-radius: 5px; transition: 0.3s; }
        button:hover { background: #fff; box-shadow: 0 0 20px #fff; }
        .selected { border: 2px solid white !important; box-shadow: 0 0 15px var(--neon); }

        .ui-panel { position: absolute; padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid var(--neon); border-radius: 10px; pointer-events: none; z-index: 10; }
        #player-info { top: 20px; left: 20px; width: 200px; }
        #wave-info { top: 20px; right: 20px; text-align: right; display: none; }
        
        .hp-container { width: 100%; height: 12px; background: #222; border-radius: 6px; overflow: hidden; margin-top: 5px; border: 1px solid #444; }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0055, #00f2ff); transition: width 0.2s ease-out; }

        #inventory { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .slot { width: 70px; height: 70px; border: 2px solid #333; background: rgba(20,20,20,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; font-size: 10px; border-radius: 10px; }
        .slot.active { border-color: var(--neon); box-shadow: 0 0 15px var(--neon); color: #fff; transform: translateY(-5px); }
        
        #chat-container { position: absolute; bottom: 100px; left: 20px; width: 250px; }
        #chat-window { height: 100px; overflow-y: auto; font-size: 12px; margin-bottom: 5px; color: #ccc; }
    </style>
</head>
<body>

    <div id="menu">
        <h1 style="letter-spacing: 8px;">NEON FRONTIER</h1>
        <p>DEINE ID: <span id="my-id" style="color:var(--neon-pink); font-size: 22px;">....</span></p>
        <input type="text" id="username" placeholder="Dein Name" value="Player1">
        <div style="margin: 10px;">
            <button id="btn-1v1" onclick="setMode('1v1')" class="selected">1 VS 1</button>
            <button id="btn-coop" onclick="setMode('coop')">COOP SURVIVAL</button>
        </div>
        <input type="text" id="remote-id" placeholder="Partner ID eingeben"><br>
        <button id="connect-btn" style="width: 100%; background: var(--neon-pink); color: white;">START GAME</button>
    </div>

    <div id="player-info" class="ui-panel">
        <b id="ui-display-name">Spieler</b>
        <div class="hp-container"><div id="hp-bar"></div></div>
        <small>WAFFE: <span id="ui-weapon-name">Pistole</span></small>
    </div>

    <div id="wave-info" class="ui-panel">
        <span style="color: var(--neon-pink)">WELLE <span id="ui-wave">1</span></span><br>
        DROIDEN: <span id="ui-enemies">0</span>
    </div>

    <div id="chat-container">
        <div id="chat-window"></div>
        <input type="text" id="chat-input" placeholder="Nachricht..." style="width: 100%; padding: 5px;">
    </div>

    <div id="inventory">
        <div class="slot active" id="slot1"><b>1</b><span>Pistole</span></div>
        <div class="slot" id="slot2"><b>2</b><span>Shotgun</span></div>
        <div class="slot" id="slot3"><b>3</b><span>Messer</span></div>
        <div class="slot" id="slot4"><b>4</b><span>Wall</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const WEAPONS = {
            1: { name: 'Pistole', dmg: 15, rate: 250, color: '#00f2ff' },
            2: { name: 'Shotgun', dmg: 10, rate: 700, color: '#ffaa00' },
            3: { name: 'Messer', dmg: 50, rate: 400, range: 60, color: '#ff0055' },
            4: { name: 'Wall', hp: 300 }
        };

        let myId = Math.floor(1000 + Math.random() * 9000).toString();
        const peer = new Peer('NF-' + myId);
        let conn;

        let gameMode = '1v1';
        let me = { id: myId, name: 'Pilot', x: 300, y: 300, hp: 100, angle: 0, weapon: 1, lastHit: 0 };
        let rival = { id: '', name: 'Gegner', x: -1000, y: -1000, hp: 100, angle: 0, weapon: 1, active: false };
        
        let walls = [], bullets = [], enemies = [], particles = [];
        let wave = 0, isHost = false, lastShotTime = 0;
        const keys = {};

        function setMode(m) {
            gameMode = m;
            document.getElementById('btn-1v1').className = m === '1v1' ? 'selected' : '';
            document.getElementById('btn-coop').className = m === 'coop' ? 'selected' : '';
        }

        peer.on('open', id => document.getElementById('my-id').innerText = id);
        peer.on('connection', c => { conn = c; isHost = true; setupConn(); });

        document.getElementById('connect-btn').onclick = () => {
            const rId = document.getElementById('remote-id').value;
            if(!rId) return;
            me.name = document.getElementById('username').value || "Pilot";
            conn = peer.connect(rId);
            isHost = false;
            setupConn();
        };

        function setupConn() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('ui-display-name').innerText = me.name;
            if(gameMode === 'coop') document.getElementById('wave-info').style.display = 'block';

            conn.on('open', () => {
                rival.active = true;
                conn.send({ type: 'init', name: me.name, mode: gameMode });
                requestAnimationFrame(gameLoop);
            });

            conn.on('data', data => {
                if(data.type === 'init') { rival.name = data.name; gameMode = data.mode; if(gameMode === 'coop') document.getElementById('wave-info').style.display = 'block'; }
                if(data.type === 'sync') { rival.x = data.x; rival.y = data.y; rival.angle = data.angle; rival.hp = data.hp; rival.weapon = data.weapon; }
                if(data.type === 'shot') bullets.push(data.b);
                if(data.type === 'build') walls.push(data.wall);
                if(data.type === 'hit') { if(data.id === me.id) { me.hp -= data.dmg; createExplosion(me.x, me.y, '#ff0055'); } }
                if(data.type === 'msg') addChat(data.sender, data.txt);
                if(data.type === 'sync_enemies') enemies = data.enemies;
                if(data.type === 'sync_wave') wave = data.wave;
                if(data.type === 'wall_break') walls = walls.filter(w => !(w.x === data.x && w.y === data.y));
            });
        }

        function addChat(sender, txt) {
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:var(--neon-pink)">${sender}:</span> ${txt}`;
            const win = document.getElementById('chat-window');
            win.appendChild(div); win.scrollTop = win.scrollHeight;
        }

        function createExplosion(x, y, col) {
            for(let i=0; i<8; i++) {
                particles.push({ x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1.0, col });
            }
        }

        window.onkeydown = e => {
            if(document.activeElement.id === 'chat-input') {
                if(e.key === 'Enter') {
                    const txt = document.getElementById('chat-input').value;
                    if(txt && conn) { addChat(me.name, txt); conn.send({ type: 'msg', sender: me.name, txt }); }
                    document.getElementById('chat-input').value = '';
                    document.getElementById('chat-input').blur();
                }
                return;
            }
            keys[e.key.toLowerCase()] = true;
            if(['1','2','3','4'].includes(e.key)) { me.weapon = parseInt(e.key); updateUI(); }
            if(e.key === 'Enter') document.getElementById('chat-input').focus();
        };
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;
        window.onmousemove = e => me.angle = Math.atan2(e.clientY - me.y, e.clientX - me.x);

        window.onmousedown = () => {
            if(document.activeElement.id === 'chat-input') return;
            const now = Date.now();
            const w = WEAPONS[me.weapon];
            if(now - lastShotTime < w.rate) return;

            if(me.weapon === 4) { // Build
                const wx = Math.floor((me.x + Math.cos(me.angle)*60)/40)*40;
                const wy = Math.floor((me.y + Math.sin(me.angle)*60)/40)*40;
                if(!walls.some(wl => wl.x === wx && wl.y === wy)) {
                    const wall = { x: wx, y: wy, hp: w.hp };
                    walls.push(wall); if(conn) conn.send({ type: 'build', wall });
                }
            } else if(me.weapon === 3) { // Knife
                if(gameMode === '1v1' && Math.hypot(me.x - rival.x, me.y - rival.y) < w.range) {
                    conn.send({ type: 'hit', id: rival.id, dmg: w.dmg });
                }
                enemies.forEach((en, i) => {
                    if(Math.hypot(me.x - en.x, me.y - en.y) < w.range) {
                        en.hp -= w.dmg; createExplosion(en.x, en.y, '#ff0000');
                    }
                });
            } else { // Guns
                const b = { x: me.x, y: me.y, vx: Math.cos(me.angle)*14, vy: Math.sin(me.angle)*14, owner: me.id, dmg: w.dmg, col: w.color };
                bullets.push(b); if(conn) conn.send({ type: 'shot', b });
                if(me.weapon === 2) { // Spread
                    [-0.2, 0.2].forEach(a => {
                        const sb = {...b, vx: Math.cos(me.angle+a)*14, vy: Math.sin(me.angle+a)*14};
                        bullets.push(sb); if(conn) conn.send({ type: 'shot', b: sb });
                    });
                }
            }
            lastShotTime = now;
        };

        function updateUI() {
            document.getElementById('hp-bar').style.width = Math.max(0, me.hp) + '%';
            document.getElementById('ui-weapon-name').innerText = WEAPONS[me.weapon].name;
            document.getElementById('ui-wave').innerText = wave;
            document.getElementById('ui-enemies').innerText = enemies.length;
            for(let i=1; i<=4; i++) document.getElementById('slot'+i).className = me.weapon === i ? 'slot active' : 'slot';
        }

        function gameLoop() {
            ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // Grid background
            ctx.strokeStyle = '#111'; ctx.lineWidth = 1; ctx.beginPath();
            for(let x=0; x<canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            // Movement & Wall Collision
            let nx = me.x, ny = me.y;
            if(keys['w']) ny -= 4; if(keys['s']) ny += 4;
            if(keys['a']) nx -= 4; if(keys['d']) nx += 4;
            
            const isColliding = (tx, ty) => walls.some(w => tx+15 > w.x && tx-15 < w.x+40 && ty+15 > w.y && ty-15 < w.y+40);
            if(!isColliding(nx, me.y)) me.x = nx;
            if(!isColliding(me.x, ny)) me.y = ny;

            if(conn) conn.send({ type: 'sync', x: me.x, y: me.y, angle: me.angle, hp: me.hp, weapon: me.weapon });

            // Particles
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 2, 2);
                if(p.life <= 0) particles.splice(i, 1);
            });
            ctx.globalAlpha = 1.0;

            // Bullets
            bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy;
                ctx.fillStyle = b.col; ctx.shadowBlur = 8; ctx.shadowColor = b.col;
                ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, 7); ctx.fill();
                
                // Wall Collision
                walls.forEach((w, wi) => {
                    if(b.x > w.x && b.x < w.x+40 && b.y > w.y && b.y < w.y+40) {
                        w.hp -= b.dmg; bullets.splice(i, 1);
                        if(w.hp <= 0) { 
                            if(conn) conn.send({type:'wall_break', x:w.x, y:w.y});
                            walls.splice(wi, 1); 
                        }
                    }
                });

                // Rival Collision
                if(gameMode === '1v1' && b.owner === me.id && Math.hypot(rival.x - b.x, rival.y - b.y) < 20) {
                    conn.send({ type: 'hit', id: rival.id, dmg: b.dmg }); bullets.splice(i, 1);
                }

                // Enemy Collision (Host side only for logic)
                if(isHost && gameMode === 'coop') {
                    enemies.forEach((en, ei) => {
                        if(Math.hypot(en.x - b.x, en.y - b.y) < 20) {
                            en.hp -= b.dmg; bullets.splice(i, 1);
                            if(en.hp <= 0) { createExplosion(en.x, en.y, '#ff0000'); enemies.splice(ei, 1); }
                        }
                    });
                }
            });

            // Smart AI (Host only)
            if(isHost && gameMode === 'coop') {
                if(enemies.length === 0) {
                    wave++;
                    for(let i=0; i<3 + wave*2; i++) {
                        enemies.push({ x: Math.random()*canvas.width, y: -50, hp: 40 + wave*10, speed: 1.2 + Math.random(), offset: Math.random()*100 });
                    }
                    conn.send({ type: 'sync_wave', wave });
                }

                enemies.forEach(en => {
                    const target = Math.hypot(me.x-en.x, me.y-en.y) < Math.hypot(rival.x-en.x, rival.y-en.y) ? me : rival;
                    const dist = Math.hypot(target.x - en.x, target.y - en.y);
                    
                    // Schlaue Bewegung: Umkreisen + Draufgehen
                    const angle = Math.atan2(target.y - en.y, target.x - en.x);
                    const orbit = Math.sin(Date.now() * 0.002 + en.offset) * 0.5; // Leichtes Schwanken
                    
                    en.x += Math.cos(angle + orbit) * en.speed;
                    en.y += Math.sin(angle + orbit) * en.speed;

                    // Schaden am Spieler + Repel (Rückstoß)
                    if(dist < 25) {
                        me.hp -= 0.5;
                        me.x += Math.cos(angle) * 10; me.y += Math.sin(angle) * 10; // Knockback
                    }
                });
                conn.send({ type: 'sync_enemies', enemies });
            }

            // Draw Entities
            walls.forEach(w => {
                ctx.strokeStyle = varColor('--neon'); ctx.strokeRect(w.x, w.y, 40, 40);
                ctx.fillStyle = `rgba(0, 242, 255, ${w.hp/300})`; ctx.fillRect(w.x+5, w.y+5, 30, 30);
            });

            enemies.forEach(en => {
                ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = 'red';
                ctx.beginPath(); ctx.arc(en.x, en.y, 12, 0, 7); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(en.x-4, en.y-4, 8, 2); // Auge
            });

            drawPlayer(me, '#00f2ff');
            if(rival.active) drawPlayer(rival, '#ff0055');

            if(me.hp <= 0) { alert("GAME OVER"); location.reload(); }
            
            ctx.shadowBlur = 0;
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function drawPlayer(p, col) {
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            ctx.shadowBlur = 15; ctx.shadowColor = col;
            ctx.fillStyle = col;
            ctx.beginPath(); ctx.moveTo(18, 0); ctx.lineTo(-12, -12); ctx.lineTo(-12, 12); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.fillRect(10, -2, 10, 4); // Waffe
            ctx.restore();
            ctx.fillStyle = '#fff'; ctx.font = "12px Arial"; ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y - 30);
        }

        function varColor(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
    </script>
</body>
</html>
